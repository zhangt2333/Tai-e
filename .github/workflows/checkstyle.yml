name: Checkstyle
on:
  pull_request:

permissions:
  checks: write
  contents: read
  pull-requests: write

jobs:
  checkstyle:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-java@v4
        with:
          java-version: 17
          distribution: temurin

      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@v4

      - name: Run Checkstyle
        run: ./gradlew checkstyleMain checkstyleTest
        continue-on-error: true

      - name: Parse Checkstyle Reports and Comment
        uses: actions/github-script@v8
        with:
          github-token: ${{secrets.GITHUB_TOKEN}}
          script: |
            const fs = require('fs');
            const path = require('path');
            const { DOMParser } = require('@xmldom/xmldom');

            console.log('=== Starting Checkstyle Report Processing ===');
            console.log('Context:', {
              owner: context.repo.owner,
              repo: context.repo.repo,
              pr: context.issue.number,
              sha: context.payload.pull_request.head.sha
            });

            // Êü•ÊâæÊâÄÊúâ checkstyle XML Êñá‰ª∂
            function findCheckstyleFiles(dir) {
              console.log(`Searching for checkstyle files in: ${dir}`);
              const files = [];

              function traverse(currentPath) {
                try {
                  const items = fs.readdirSync(currentPath);

                  for (const item of items) {
                    const fullPath = path.join(currentPath, item);
                    const stat = fs.statSync(fullPath);

                    if (stat.isDirectory()) {
                      // Ê£ÄÊü•ÊòØÂê¶ÊòØ build/reports/checkstyle ÁõÆÂΩï
                      if (fullPath.includes('build/reports/checkstyle')) {
                        console.log(`Found checkstyle directory: ${fullPath}`);
                        const xmlFiles = fs.readdirSync(fullPath)
                          .filter(f => f.endsWith('.xml'))
                          .map(f => path.join(fullPath, f));
                        files.push(...xmlFiles);
                        console.log(`Found XML files: ${xmlFiles}`);
                      } else if (!item.startsWith('.') && item !== 'node_modules') {
                        traverse(fullPath);
                      }
                    }
                  }
                } catch (err) {
                  console.log(`Error traversing ${currentPath}: ${err.message}`);
                }
              }

              traverse(dir);
              return files;
            }

            // Ëß£Êûê XML Êñá‰ª∂
            function parseCheckstyleXML(xmlContent, xmlFile) {
              console.log(`\nParsing XML file: ${xmlFile}`);
              console.log(`XML content length: ${xmlContent.length} chars`);

              const parser = new DOMParser();
              const doc = parser.parseFromString(xmlContent, 'text/xml');
              const violations = [];

              const fileNodes = doc.getElementsByTagName('file');
              console.log(`Found ${fileNodes.length} file nodes`);

              for (let i = 0; i < fileNodes.length; i++) {
                const fileNode = fileNodes[i];
                const fileName = fileNode.getAttribute('name');
                console.log(`  Processing file: ${fileName}`);

                // ËΩ¨Êç¢‰∏∫Áõ∏ÂØπË∑ØÂæÑ
                let relativePath = fileName;
                if (fileName.startsWith('/')) {
                  // Â∞ùËØïÊèêÂèñÁõ∏ÂØπË∑ØÂæÑ
                  const srcIndex = fileName.indexOf('src/');
                  if (srcIndex !== -1) {
                    relativePath = fileName.substring(srcIndex);
                  }
                } else if (fileName.includes('/src/')) {
                  const srcIndex = fileName.indexOf('src/');
                  relativePath = fileName.substring(srcIndex);
                }

                console.log(`    Relative path: ${relativePath}`);

                const errorNodes = fileNode.getElementsByTagName('error');
                console.log(`    Found ${errorNodes.length} errors`);

                for (let j = 0; j < errorNodes.length; j++) {
                  const error = errorNodes[j];
                  const violation = {
                    file: relativePath,
                    line: parseInt(error.getAttribute('line') || '1'),
                    column: error.getAttribute('column') ? parseInt(error.getAttribute('column')) : null,
                    severity: error.getAttribute('severity'),
                    message: error.getAttribute('message'),
                    source: error.getAttribute('source')
                  };

                  console.log(`    Violation: Line ${violation.line}, Severity: ${violation.severity}`);
                  violations.push(violation);
                }
              }

              return violations;
            }

            // ÂàõÂª∫ËØÑËÆ∫ÂÜÖÂÆπ
            function createCommentBody(violations) {
              const parts = [];

              // Ê∑ªÂä†ÂõæÊ†á
              const icon = violations.some(v => v.severity === 'error') ? '‚ùå' : '‚ö†Ô∏è';

              parts.push(`${icon} **Checkstyle Violation**\n`);

              // Êåâ‰∏•ÈáçÁ®ãÂ∫¶ÂàÜÁªÑ
              for (const violation of violations) {
                const severityIcon = violation.severity === 'error' ? 'üî¥' : 'üü°';
                parts.push(`${severityIcon} **${violation.severity.toUpperCase()}**`);

                if (violation.column) {
                  parts.push(`Line ${violation.line}, Column ${violation.column}`);
                } else {
                  parts.push(`Line ${violation.line}`);
                }

                parts.push(`\n${violation.message}`);

                if (violation.source) {
                  const ruleName = violation.source.split('.').pop();
                  parts.push(`\n_Rule: ${ruleName}_`);
                }
              }

              return parts.join('\n');
            }

            // ‰∏ªÂ§ÑÁêÜÈÄªËæë
            try {
              const checkstyleFiles = findCheckstyleFiles('.');

              if (checkstyleFiles.length === 0) {
                console.log('No checkstyle XML files found');
                return;
              }

              console.log(`\nFound ${checkstyleFiles.length} checkstyle files total`);

              // Êî∂ÈõÜÊâÄÊúâËøùËßÑ
              const allViolations = [];

              for (const xmlFile of checkstyleFiles) {
                console.log(`\nReading file: ${xmlFile}`);
                try {
                  const xmlContent = fs.readFileSync(xmlFile, 'utf8');
                  const violations = parseCheckstyleXML(xmlContent, xmlFile);
                  allViolations.push(...violations);
                } catch (err) {
                  console.error(`Error processing ${xmlFile}: ${err.message}`);
                }
              }

              console.log(`\n=== Total violations found: ${allViolations.length} ===`);

              if (allViolations.length === 0) {
                console.log('No violations to report');
                return;
              }

              // ÊåâÊñá‰ª∂ÂíåË°åÂè∑ÂàÜÁªÑËøùËßÑ
              const violationsByLocation = {};

              for (const violation of allViolations) {
                const key = `${violation.file}:${violation.line}`;
                if (!violationsByLocation[key]) {
                  violationsByLocation[key] = {
                    file: violation.file,
                    line: violation.line,
                    violations: []
                  };
                }
                violationsByLocation[key].violations.push(violation);
              }

              console.log(`\nGrouped into ${Object.keys(violationsByLocation).length} unique locations`);

              // Ëé∑ÂèñÂ∑≤Â≠òÂú®ÁöÑËØÑËÆ∫‰ª•ÈÅøÂÖçÈáçÂ§ç
              console.log('\nFetching existing comments...');
              const existingComments = await github.rest.pulls.listReviewComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.issue.number
              });

              console.log(`Found ${existingComments.data.length} existing comments`);

              // ÂàõÂª∫ËØÑËÆ∫
              let successCount = 0;
              let skipCount = 0;
              let errorCount = 0;

              for (const [key, location] of Object.entries(violationsByLocation)) {
                console.log(`\nProcessing location: ${key}`);

                // Ê£ÄÊü•ÊòØÂê¶Â∑≤ÊúâËØÑËÆ∫Âú®Áõ∏Âêå‰ΩçÁΩÆ
                const existingComment = existingComments.data.find(c =>
                  c.path === location.file &&
                  c.line === location.line &&
                  c.body.includes('Checkstyle Violation')
                );

                if (existingComment) {
                  console.log(`  Skipping - comment already exists at ${location.file}:${location.line}`);
                  skipCount++;
                  continue;
                }

                const body = createCommentBody(location.violations);
                console.log(`  Creating comment for ${location.file}:${location.line}`);
                console.log(`  Comment body length: ${body.length} chars`);

                try {
                  await github.rest.pulls.createReviewComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: context.issue.number,
                    body: body,
                    path: location.file,
                    line: location.line,
                    side: 'RIGHT',
                    commit_id: context.payload.pull_request.head.sha
                  });

                  console.log(`  ‚úì Comment created successfully`);
                  successCount++;

                  // Ê∑ªÂä†Âª∂Ëøü‰ª•ÈÅøÂÖç API ÈôêÂà∂
                  await new Promise(resolve => setTimeout(resolve, 100));

                } catch (err) {
                  console.error(`  ‚úó Failed to create comment: ${err.message}`);
                  console.error(`    Error details:`, err);
                  errorCount++;
                }
              }

              console.log('\n=== Summary ===');
              console.log(`Total violations: ${allViolations.length}`);
              console.log(`Unique locations: ${Object.keys(violationsByLocation).length}`);
              console.log(`Comments created: ${successCount}`);
              console.log(`Comments skipped (already exist): ${skipCount}`);
              console.log(`Errors: ${errorCount}`);

              // Â¶ÇÊûúÊúâÈîôËØØÔºåËÆ© action Â§±Ë¥•
              if (errorCount > 0 && successCount === 0) {
                core.setFailed(`Failed to create any comments. ${errorCount} errors occurred.`);
              }

            } catch (error) {
              console.error('Fatal error:', error);
              core.setFailed(error.message);
            }

