name: Checkstyle
on:
  pull_request:

permissions:
  checks: write
  contents: read
  pull-requests: write

jobs:
  checkstyle:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-java@v4
        with:
          java-version: 17
          distribution: temurin

      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@v4

      - name: Run Checkstyle
        run: ./gradlew checkstyleMain checkstyleTest
        continue-on-error: true

      - name: Install xml2js
        run: npm install xml2js

      - name: Parse Checkstyle Reports and Comment
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const xml2js = require('xml2js');

            console.log('ğŸ” Starting Checkstyle report analysis...');

            // ä½¿ç”¨ @actions/glob æŸ¥æ‰¾æ‰€æœ‰ checkstyle XML æŠ¥å‘Šæ–‡ä»¶
            const globber = await glob.create('**/build/reports/checkstyle/*.xml');
            const reportFiles = await globber.glob();

            console.log(`ğŸ“ Found ${reportFiles.length} checkstyle report files:`);
            reportFiles.forEach(file => console.log(`  - ${file}`));

            if (reportFiles.length === 0) {
              console.log('âš ï¸ No checkstyle report files found');
              return;
            }

            const parser = new xml2js.Parser();
            let totalViolations = 0;
            const allViolations = [];

            // è§£ææ¯ä¸ª XML æ–‡ä»¶
            for (const reportFile of reportFiles) {
              console.log(`\nğŸ“„ Processing file: ${reportFile}`);

              try {
                const xmlContent = fs.readFileSync(reportFile, 'utf8');
                console.log(`ğŸ“ XML content length: ${xmlContent.length} characters`);

                const result = await parser.parseStringPromise(xmlContent);
                console.log(`ğŸ” Parsed XML structure:`, JSON.stringify(result, null, 2));

                if (!result.checkstyle || !result.checkstyle.file) {
                  console.log('âš ï¸ No files found in checkstyle report');
                  continue;
                }

                const files = Array.isArray(result.checkstyle.file) ? result.checkstyle.file : [result.checkstyle.file];
                console.log(`ğŸ“‚ Processing ${files.length} files in report`);

                for (const file of files) {
                  const fileName = file.$.name;
                  console.log(`\nğŸ” Analyzing file: ${fileName}`);

                  if (!file.error) {
                    console.log('âœ… No errors found in this file');
                    continue;
                  }

                  const errors = Array.isArray(file.error) ? file.error : [file.error];
                  console.log(`âŒ Found ${errors.length} errors in ${fileName}`);

                  for (const error of errors) {
                    const violation = {
                      file: fileName,
                      line: parseInt(error.$.line),
                      column: error.$.column ? parseInt(error.$.column) : null,
                      severity: error.$.severity,
                      message: error.$.message.replace(/&apos;/g, "'").replace(/&quot;/g, '"').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&amp;/g, '&'),
                      source: error.$.source,
                      reportFile: reportFile
                    };

                    allViolations.push(violation);
                    totalViolations++;

                    console.log(`  ğŸ“ Line ${violation.line}${violation.column ? `, Column ${violation.column}` : ''}: ${violation.message}`);
                  }
                }

              } catch (error) {
                console.error(`âŒ Error processing ${reportFile}:`, error);
              }
            }

            console.log(`\nğŸ“Š Summary: Found ${totalViolations} total violations across all files`);

            if (totalViolations === 0) {
              console.log('ğŸ‰ No checkstyle violations found!');
              return;
            }

            // æŒ‰æ–‡ä»¶åˆ†ç»„è¿è§„
            const violationsByFile = {};
            allViolations.forEach(violation => {
              if (!violationsByFile[violation.file]) {
                violationsByFile[violation.file] = [];
              }
              violationsByFile[violation.file].push(violation);
            });

            console.log(`\nğŸ“ Violations grouped by ${Object.keys(violationsByFile).length} files`);

            // ä¸ºæ¯ä¸ªæ–‡ä»¶çš„æ¯ä¸ªè¿è§„åˆ›å»ºè¯„è®º
            let commentCount = 0;
            const maxComments = 20; // é™åˆ¶è¯„è®ºæ•°é‡é¿å…spam

            for (const [filePath, violations] of Object.entries(violationsByFile)) {
              console.log(`\nğŸ’¬ Processing comments for: ${filePath}`);

              // è½¬æ¢ç»å¯¹è·¯å¾„ä¸ºç›¸å¯¹è·¯å¾„
              const relativePath = filePath.replace(process.cwd() + '/', '').replace(/^\/+/, '');
              console.log(`ğŸ“ Relative path: ${relativePath}`);
              console.log(`ğŸ“ Current working directory: ${process.cwd()}`);

              for (const violation of violations) {
                if (commentCount >= maxComments) {
                  console.log(`âš ï¸ Reached maximum comment limit (${maxComments}), stopping...`);
                  break;
                }

                const commentBody = `**Checkstyle ${violation.severity.toUpperCase()}**\n\n` +
                  `${violation.message}\n\n` +
                  `**Rule:** \`${violation.source.split('.').pop()}\`\n` +
                  `**File:** ${violation.file}\n` +
                  `**Line:** ${violation.line}${violation.column ? `, Column: ${violation.column}` : ''}\n` +
                  `**Report:** ${path.basename(violation.reportFile)}`;

                console.log(`\nğŸ“ Creating comment for line ${violation.line}:`);
                console.log(`   Message: ${violation.message}`);
                console.log(`   Severity: ${violation.severity}`);
                console.log(`   Path for API: ${relativePath}`);
                console.log(`   Commit SHA: ${context.payload.pull_request.head.sha}`);

                try {
                  const response = await github.rest.pulls.createReviewComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: context.issue.number,
                    body: commentBody,
                    path: relativePath,
                    line: violation.line,
                    side: 'RIGHT',
                    commit_id: context.payload.pull_request.head.sha
                  });

                  commentCount++;
                  console.log(`âœ… Comment created successfully (ID: ${response.data.id})`);

                } catch (error) {
                  console.error(`âŒ Failed to create comment for ${relativePath}:${violation.line}:`, error.message);
                  console.error(`   Error status: ${error.status}`);
                  console.error(`   Error response:`, error.response?.data);

                  // å¦‚æœæ˜¯è·¯å¾„é—®é¢˜ï¼Œå°è¯•ä¸åŒçš„è·¯å¾„æ ¼å¼
                  if (error.status === 422) {
                    console.log(`ğŸ”„ Trying alternative path formats...`);
                    const altPaths = [
                      filePath.replace(/^.*\/src\//, 'src/'),
                      filePath.split('/').slice(-5).join('/'), // å–æœ€å5ä¸ªè·¯å¾„ç»„ä»¶
                      path.basename(filePath) // åªç”¨æ–‡ä»¶åè¯•è¯•
                    ];

                    for (const altPath of altPaths) {
                      console.log(`   Trying path: ${altPath}`);
                      try {
                        const altResponse = await github.rest.pulls.createReviewComment({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          pull_number: context.issue.number,
                          body: commentBody,
                          path: altPath,
                          line: violation.line,
                          side: 'RIGHT',
                          commit_id: context.payload.pull_request.head.sha
                        });
                        console.log(`âœ… Alternative path worked! (ID: ${altResponse.data.id})`);
                        commentCount++;
                        break;
                      } catch (altError) {
                        console.log(`   Alternative path failed: ${altError.message}`);
                      }
                    }
                  }
                }
              }

              if (commentCount >= maxComments) break;
            }

            // åˆ›å»ºæ€»ç»“è¯„è®º
            const summaryComment = `## ğŸ“‹ Checkstyle Report Summary\n\n` +
              `Found **${totalViolations}** checkstyle violations across **${Object.keys(violationsByFile).length}** files.\n\n` +
              `${commentCount < totalViolations ? `âš ï¸ Showing first ${commentCount} violations (limited to avoid spam).\n\n` : ''}` +
              `### Files with violations:\n` +
              Object.entries(violationsByFile).map(([file, viols]) =>
                `- \`${file}\`: ${viols.length} violation${viols.length > 1 ? 's' : ''}`
              ).join('\n') + '\n\n' +
              `### Severity breakdown:\n` +
              (() => {
                const severityCount = {};
                allViolations.forEach(v => {
                  severityCount[v.severity] = (severityCount[v.severity] || 0) + 1;
                });
                return Object.entries(severityCount).map(([sev, count]) =>
                  `- ${sev.toUpperCase()}: ${count}`
                ).join('\n');
              })() + '\n\n' +
              `### Report files processed:\n` +
              reportFiles.map(file => `- \`${path.basename(file)}\``).join('\n') + '\n\n' +
              `*Generated by Checkstyle GitHub Action*`;

            console.log(`\nğŸ“„ Creating summary comment...`);
            console.log(`Summary preview:\n${summaryComment.substring(0, 200)}...`);

            try {
              const summaryResponse = await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: summaryComment
              });

              console.log(`âœ… Summary comment created successfully (ID: ${summaryResponse.data.id})`);
            } catch (error) {
              console.error(`âŒ Failed to create summary comment:`, error.message);
              console.error(`   Error details:`, error);
            }

            console.log(`\nğŸ¯ Process completed!`);
            console.log(`ğŸ“Š Final stats:`);
            console.log(`   - Total violations: ${totalViolations}`);
            console.log(`   - Files processed: ${Object.keys(violationsByFile).length}`);
            console.log(`   - Comments created: ${commentCount}`);
            console.log(`   - Report files: ${reportFiles.length}`);
            console.log(`   - Working directory: ${process.cwd()}`);
            console.log(`   - Repository: ${context.repo.owner}/${context.repo.repo}`);
            console.log(`   - PR number: ${context.issue.number}`);
